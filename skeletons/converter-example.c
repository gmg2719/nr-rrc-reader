/*
 * Generic converter template for a selected ASN.1 type.
 * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>.
 * All rights reserved.
 * 
 * To compile with your own ASN.1 type, redefine the PDU as shown:
 * 
 * cc -DPDU=MyCustomType -o myDecoder.o -c converter-example.c
 */
#ifdef    HAVE_CONFIG_H
#include <config.h>
#endif
#define __EXTENSIONS__
#include <errno.h> /* for errno */
#include <skeletons/asn_application.h>
#include <skeletons/asn_internal.h> /* for ASN__DEFAULT_STACK_MAX */
#include <stdio.h>
#include <stdlib.h> /* for atoi(3) */
#include <string.h> /* for strerror(3) */
#include <sys/types.h>

/* Convert "Type" defined by -DPDU into "asn_DEF_Type" */
#ifdef PDU
#define    ASN_DEF_PDU(t)    asn_DEF_ ## t
#define    DEF_PDU_Type(t)    ASN_DEF_PDU(t)
#define    PDU_Type    DEF_PDU_Type(PDU)
extern asn_TYPE_descriptor_t PDU_Type;    /* ASN.1 type to be decoded */
#define PDU_Type_Ptr (&PDU_Type)
#else   /* !PDU */
#define PDU_Type_Ptr    NULL
#endif  /* PDU */

#ifdef ASN_PDU_COLLECTION /* Generated by asn1c -pdu=... */
extern asn_TYPE_descriptor_t *asn_pdu_collection[];
#endif


/*
 * Open file and parse its contens.
 */
static void *data_decode_from_file(enum asn_transfer_syntax,
                                   asn_TYPE_descriptor_t *asnTypeOfPDU,
                                   FILE *file, const char *name,
                                   ssize_t suggested_bufsize, int first_pdu);
static int write_out(const void *buffer, size_t size, void *key);
static FILE *argument_to_file(char *av[], int idx);
static char *argument_to_name(char *av[], int idx);

       int opt_debug;   /* -d (or -dd) */
static int opt_check;   /* -c (constraints checking) */
static int opt_stack;   /* -s (maximum stack size) */
static int opt_nopad;   /* -per-nopad (PER input is not padded between msgs) */
static int opt_onepdu;  /* -1 (decode single PDU) */

#ifdef    JUNKTEST        /* Enable -J <probability> */
#define JUNKOPT "J:"
static double opt_jprob;    /* Junk bit probability */
static int    junk_failures;
static void   junk_bytes_with_probability(uint8_t *, size_t, double prob);

#define RANDOPT "R:"
static ssize_t random_max_size = 0; /* Size of the random data */

#if !defined(__FreeBSD__) && !(defined(__APPLE__) && defined(__MACH__))
static void
srandomdev(void) {
    FILE *f = fopen("/dev/urandom", "rb");
    unsigned seed;
    if(f) {
        if(fread(&seed, 1, sizeof(seed), f) != sizeof(seed)) {
            seed = time(NULL);
        }
        fclose(f);
    } else {
        seed = time(NULL);
    }
    srandom(seed);
}
#endif

#else   /* !JUNKTEST */
#define    JUNKOPT
#define    RANDOPT
#endif  /* JUNKTEST */

/* Debug output function */
static void CC_PRINTFLIKE(1, 2)
DEBUG(const char *fmt, ...) {
    va_list ap;
    if(!opt_debug) return;
    fprintf(stderr, "AD: ");
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fprintf(stderr, "\n");
}

static const char *
ats_simple_name(enum asn_transfer_syntax syntax) {
    switch(syntax) {
    case ATS_INVALID:
        return "/dev/null";
    case ATS_NONSTANDARD_PLAINTEXT:
        return "plaintext";
    case ATS_BER:
        return "BER";
    case ATS_DER:
        return "DER";
    case ATS_CER:
        return "CER";
    case ATS_BASIC_OER:
    case ATS_CANONICAL_OER:
        return "OER";
    case ATS_BASIC_XER:
    case ATS_CANONICAL_XER:
        return "XER";
    case ATS_UNALIGNED_BASIC_PER:
    case ATS_UNALIGNED_CANONICAL_PER:
        return "PER";
    default:
        return "<?>";
    }
}

#define CODEC_OFFSET(fname)  ((ptrdiff_t)&(((asn_TYPE_operation_t *)0)->fname))
typedef struct {
    const char *name;
    enum asn_transfer_syntax syntax;
    ptrdiff_t codec_offset;
    const char *full_name;
} syntax_selector;

static syntax_selector input_encodings[] = {
    {"ber", ATS_BER, CODEC_OFFSET(ber_decoder),
     "Input is in BER (Basic Encoding Rules) or DER"},
    {"oer", ATS_BASIC_OER, CODEC_OFFSET(oer_decoder),
     "Input is in OER (Octet Encoding Rules)"},
    {"per", ATS_UNALIGNED_BASIC_PER, CODEC_OFFSET(uper_decoder),
     "Input is in Unaligned PER (Packed Encoding Rules)"},
    {"aper", ATS_ALIGNED_BASIC_PER, CODEC_OFFSET(aper_decoder),
     "Input is in Aligned PER (Packed Encoding Rules)"},
    {"xer", ATS_BASIC_XER, CODEC_OFFSET(xer_decoder),
     "Input is in XER (XML Encoding Rules)"},
    {0, ATS_INVALID, 0, 0}};

static syntax_selector output_encodings[] = {
    {"der", ATS_DER, CODEC_OFFSET(der_encoder),
     "Output as DER (Distinguished Encoding Rules)"},
    {"oer", ATS_CANONICAL_OER, CODEC_OFFSET(oer_encoder),
     "Output as Canonical OER (Octet Encoding Rules)"},
    {"per", ATS_UNALIGNED_CANONICAL_PER, CODEC_OFFSET(uper_encoder),
     "Output as Unaligned PER (Packed Encoding Rules)"},
    {"aper", ATS_ALIGNED_CANONICAL_PER, CODEC_OFFSET(aper_encoder),
     "Output as Aligned PER (Packed Encoding Rules)"},
    {"xer", ATS_BASIC_XER, CODEC_OFFSET(xer_encoder),
     "Output as XER (XML Encoding Rules)"},
    {"text", ATS_NONSTANDARD_PLAINTEXT, CODEC_OFFSET(print_struct),
     "Output as plain semi-structured text"},
    {"null", ATS_INVALID, CODEC_OFFSET(print_struct),
     "Verify (decode) input, but do not output"},
    {0, ATS_INVALID, 0, 0}};

static int
has_codec_defined(const asn_TYPE_descriptor_t *td,
                  const syntax_selector *element) {
    return *(const void *const *)(const void *)((const char *)td->op
                                                + element->codec_offset) != 0;
}

/*
 * Select ASN.1 Transfer Enocoding Syntax by command line name.
 */
static const syntax_selector *
ats_by_name(const char *name, const asn_TYPE_descriptor_t *td,
            const syntax_selector *first_element) {
    const syntax_selector *element;
    for(element = first_element; element->name; element++) {
        if(strcmp(element->name, name) == 0) {
            if(td && td->op && has_codec_defined(td, element)) {
                return element;
            }
        }
    }
    return NULL;
}

static struct dynamic_buffer {
    uint8_t *data;        /* Pointer to the data bytes */
    size_t offset;        /* Offset from the start */
    size_t length;        /* Length of meaningful contents */
    size_t unbits;        /* Unused bits in the last byte */
    size_t allocated;    /* Allocated memory for data */
    int    nreallocs;    /* Number of data reallocations */
    off_t  bytes_shifted;    /* Number of bytes ever shifted */
} DynamicBuffer;

static void
buffer_dump() {
    uint8_t *p = DynamicBuffer.data + DynamicBuffer.offset;
    uint8_t *e = p + DynamicBuffer.length - (DynamicBuffer.unbits ? 1 : 0);
    if(!opt_debug) return;
    DEBUG("Buffer: { d=%p, o=%" ASN_PRI_SIZE ", l=%" ASN_PRI_SIZE
          ", u=%" ASN_PRI_SIZE ", a=%" ASN_PRI_SIZE ", s=%" ASN_PRI_SIZE " }",
        (const void *)DynamicBuffer.data,
        DynamicBuffer.offset,
        DynamicBuffer.length,
        DynamicBuffer.unbits,
        DynamicBuffer.allocated,
        (size_t)DynamicBuffer.bytes_shifted);
    for(; p < e; p++) {
        fprintf(stderr, " %c%c%c%c%c%c%c%c",
            ((*p >> 7) & 1) ? '1' : '0',
            ((*p >> 6) & 1) ? '1' : '0',
            ((*p >> 5) & 1) ? '1' : '0',
            ((*p >> 4) & 1) ? '1' : '0',
            ((*p >> 3) & 1) ? '1' : '0',
            ((*p >> 2) & 1) ? '1' : '0',
            ((*p >> 1) & 1) ? '1' : '0',
            ((*p >> 0) & 1) ? '1' : '0');
    }
    if(DynamicBuffer.unbits) {
        unsigned int shift;
        fprintf(stderr, " ");
        for(shift = 7; shift >= DynamicBuffer.unbits; shift--)
            fprintf(stderr, "%c", ((*p >> shift) & 1) ? '1' : '0');
        fprintf(stderr, " %" ASN_PRI_SSIZE ":%" ASN_PRI_SSIZE "\n",
                (ssize_t)DynamicBuffer.length - 1,
                (ssize_t)8 - DynamicBuffer.unbits);
    } else {
        fprintf(stderr, " %ld\n", (long)DynamicBuffer.length);
    }
}

/*
 * Move the buffer content left N bits, possibly joining it with
 * preceeding content.
 */
static void
buffer_shift_left(size_t offset, int bits) {
    uint8_t *ptr = DynamicBuffer.data + DynamicBuffer.offset + offset;
    uint8_t *end = DynamicBuffer.data + DynamicBuffer.offset
            + DynamicBuffer.length - 1;
    
    if(!bits) return;

    DEBUG("Shifting left %d bits off %ld (o=%ld, u=%ld, l=%ld)",
        bits, (long)offset,
        (long)DynamicBuffer.offset,
        (long)DynamicBuffer.unbits,
        (long)DynamicBuffer.length);

    if(offset) {
        int right;
        right = ptr[0] >> (8 - bits);

        DEBUG("oleft: %c%c%c%c%c%c%c%c",
            ((ptr[-1] >> 7) & 1) ? '1' : '0',
            ((ptr[-1] >> 6) & 1) ? '1' : '0',
            ((ptr[-1] >> 5) & 1) ? '1' : '0',
            ((ptr[-1] >> 4) & 1) ? '1' : '0',
            ((ptr[-1] >> 3) & 1) ? '1' : '0',
            ((ptr[-1] >> 2) & 1) ? '1' : '0',
            ((ptr[-1] >> 1) & 1) ? '1' : '0',
            ((ptr[-1] >> 0) & 1) ? '1' : '0');

        DEBUG("oriht: %c%c%c%c%c%c%c%c",
            ((ptr[0] >> 7) & 1) ? '1' : '0',
            ((ptr[0] >> 6) & 1) ? '1' : '0',
            ((ptr[0] >> 5) & 1) ? '1' : '0',
            ((ptr[0] >> 4) & 1) ? '1' : '0',
            ((ptr[0] >> 3) & 1) ? '1' : '0',
            ((ptr[0] >> 2) & 1) ? '1' : '0',
            ((ptr[0] >> 1) & 1) ? '1' : '0',
            ((ptr[0] >> 0) & 1) ? '1' : '0');

        DEBUG("mriht: %c%c%c%c%c%c%c%c",
            ((right >> 7) & 1) ? '1' : '0',
            ((right >> 6) & 1) ? '1' : '0',
            ((right >> 5) & 1) ? '1' : '0',
            ((right >> 4) & 1) ? '1' : '0',
            ((right >> 3) & 1) ? '1' : '0',
            ((right >> 2) & 1) ? '1' : '0',
            ((right >> 1) & 1) ? '1' : '0',
            ((right >> 0) & 1) ? '1' : '0');

        ptr[-1] = (ptr[-1] & (0xff << bits)) | right;

        DEBUG("after: %c%c%c%c%c%c%c%c",
            ((ptr[-1] >> 7) & 1) ? '1' : '0',
            ((ptr[-1] >> 6) & 1) ? '1' : '0',
            ((ptr[-1] >> 5) & 1) ? '1' : '0',
            ((ptr[-1] >> 4) & 1) ? '1' : '0',
            ((ptr[-1] >> 3) & 1) ? '1' : '0',
            ((ptr[-1] >> 2) & 1) ? '1' : '0',
            ((ptr[-1] >> 1) & 1) ? '1' : '0',
            ((ptr[-1] >> 0) & 1) ? '1' : '0');
    }

    buffer_dump();

    for(; ptr < end; ptr++) {
        int right = ptr[1] >> (8 - bits);
        *ptr = (*ptr << bits) | right;
    }
    *ptr <<= bits;

    DEBUG("Unbits [%" ASN_PRI_SIZE "=>", DynamicBuffer.unbits);
    if(DynamicBuffer.unbits == 0) {
        DynamicBuffer.unbits += bits;
    } else {
        DynamicBuffer.unbits += bits;
        if(DynamicBuffer.unbits > 7) {
            DynamicBuffer.unbits -= 8;
            DynamicBuffer.length--;
            DynamicBuffer.bytes_shifted++;
        }
    }
    DEBUG("Unbits =>%" ASN_PRI_SIZE "]", DynamicBuffer.unbits);

    buffer_dump();

    DEBUG("Shifted. Now (o=%" ASN_PRI_SIZE ", u=%" ASN_PRI_SIZE
          " l=%" ASN_PRI_SIZE ")",
        DynamicBuffer.offset,
        DynamicBuffer.unbits,
        DynamicBuffer.length);
}


static int
is_syntax_PER(enum asn_transfer_syntax syntax) {
    return (syntax == ATS_UNALIGNED_BASIC_PER
            || syntax == ATS_UNALIGNED_CANONICAL_PER
            || syntax == ATS_ALIGNED_BASIC_PER
            || syntax == ATS_ALIGNED_CANONICAL_PER);
}

static int
restartability_supported(enum asn_transfer_syntax syntax) {
    return !is_syntax_PER(syntax);
}


/* Dump the buffer out to the specified FILE */
static int write_out(const void *buffer, size_t size, void *key) {
    FILE *fp = (FILE *)key;
    return (fwrite(buffer, 1, size, fp) == size) ? 0 : -1;
}

static int argument_is_stdin(char *av[], int idx) {
    if(strcmp(av[idx], "-")) {
        return 0; /* Certainly not <stdin> */
    } else {
        /* This might be <stdin>, unless `./program -- -` */
        if(strcmp(av[-1], "--"))
            return 1;
        else
            return 0;
    }
}

static FILE *argument_to_file(char *av[], int idx) {
    return argument_is_stdin(av, idx) ? stdin : fopen(av[idx], "rb");
}

static char *argument_to_name(char *av[], int idx) {
    return argument_is_stdin(av, idx) ? "standard input" : av[idx];
}

#ifdef    JUNKTEST
/*
 * Fill bytes with some garbage with specified probability (more or less).
 */
static void
junk_bytes_with_probability(uint8_t *buf, size_t size, double prob) {
    static int junkmode;
    uint8_t *ptr;
    uint8_t *end;
    if(opt_jprob <= 0.0) return;
    for(ptr = buf, end = ptr + size; ptr < end; ptr++) {
        int byte = *ptr;
        if(junkmode++ & 1) {
            if((((double)random() / RAND_MAX) < prob))
                byte = random() & 0xff;
        } else {
#define    BPROB(b)    ((((double)random() / RAND_MAX) < prob) ? b : 0)
            byte ^= BPROB(0x80);
            byte ^= BPROB(0x40);
            byte ^= BPROB(0x20);
            byte ^= BPROB(0x10);
            byte ^= BPROB(0x08);
            byte ^= BPROB(0x04);
            byte ^= BPROB(0x02);
            byte ^= BPROB(0x01);
        }
        if(byte != *ptr) {
            *ptr = byte;
        }
    }
}
#endif    /* JUNKTEST */

